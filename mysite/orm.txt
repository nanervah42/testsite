python manage.py shell
from news.models import News, Category
News.objects.get(title='News 5')
news5 = _
news5.title
news5.category
news5.category.title


cat4 = Category.objects.get(pk=4)
cat4.news_set.all()    # получение всех связанных с первичной моделью(Category) данных из вторичной модели(News) (<имя связанной модели>_set)


News.objects.filter(pk__gt=12)  # получение новостей, где pk>12, иными словами select * from ... where pk>12
	через запятую можно добавлять иные фильтры (pk__gt=12, title__contains='news'), что равнозначно оператору WHERE ... AND ...  в sql

Чтобы получить все записи из связанных данных не по идентификатору первичной модели,а например по тайтлу первичной модели
используется запись вида <имя поля внешного ключа>__<имя поля первичной модели> например:
News.objects.filter(category__title='Политика') - получаем все данные модели News, где категория равна Политика


Category.objects.filter(news__title__contains='News') - получаем названия категорий из модели Category, если поле title вторичной модели News
содержит в себе ключевое слово 'News'
Category.objects.filter(news__title__contains='News').distinct() - тоже самое, но только уникальные значения



Класс Q
from django.db.models import Q
| - или
& - и
~ - не

News.objects.filter(Q(pk__in=[2, 3]) | Q(title__contains='формы 2')) - получаем новости с pk 2 и 3, а также новость, которая содержит "формы 2"
News.objects.filter(Q(pk__in=[2, 3]) | Q(title__contains='формы 2') & ~Q(pk__gt=4)) - тоже самое и pk не должен быть больше 4